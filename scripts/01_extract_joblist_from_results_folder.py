"""Usage:
  extract_joblist_from_results_folder.py [--input_path=<input_path>] [--output_path=<output_path>] [--verbosity=<verbosity>] [--dry-run] 

Arguments:
  -i --input_path=<input_path>    Path to a 'results' folder generated by https://github.com/theislab/jump-cpg0016-segmentation.
  -o --output_path=<output_path>  Path to the output directory [default: ./output].
  -v --verbosity=<verbosity>      Verbosity level (0-3) [default: 1].

Options:
  -h --help                       Show this screen.
  --dry-run                       Perform a dry run without making any changes.
"""

from docopt import docopt
from pathlib import Path
from lamin_utils import logger
import sys


class PathValidationError(Exception):
    pass


def validate_paths(input_path: Path, output_path: Path, verbosity: int, dry_run: bool):
    if not input_path:
        raise PathValidationError("Input path not provided.")
    if not output_path:
        raise PathValidationError("Output path not provided.")

    if not input_path.exists():
        raise PathValidationError(f"The input path '{input_path}' does not exist.")
    if verbosity > 0:
        logger.info(f"Valid input path: {input_path}")

    if not output_path.exists():
        logger.warning(f"The output path '{output_path}' does not exist.")

        if dry_run:
            logger.info(f"Dry run: Would create output path '{output_path}'")
        else:
            logger.info(f"Creating output path: {output_path}")
            output_path.mkdir(parents=True, exist_ok=True)

    if verbosity > 0:
        logger.info(f"Valid output path: {output_path}")


def main():
    arguments = docopt(__doc__, version="v0.1.0")

    input_path = arguments["--input_path"]
    output_path = arguments["--output_path"]
    dry_run = arguments["--dry-run"]
    verbosity = int(arguments["--verbosity"])

    input_path = Path(input_path).resolve() if input_path else None
    output_path = Path(output_path).resolve() if output_path else None

    try:
        validate_paths(input_path, output_path, verbosity, dry_run)
    except PathValidationError as e:
        logger.error(e)
        sys.exit(1)

    if dry_run:
        logger.info("Dry run mode enabled. No changes will be made.")

    if verbosity > 0:
        logger.info(f"Dry run: {'enabled' if dry_run else 'disabled'}")
        logger.info(f"Verbosity level: {verbosity}")

    # figure out how many sources exist in that results folder
    path_results_to_sources = input_path / Path(
        "aggregated/broad_compressed/cellpainting-gallery/cpg0016-jump/"
    )
    if not path_results_to_sources.exists():
        logger.error(f"Path '{path_results_to_sources}' does not exist.")
        sys.exit(1)

    sources = [f for f in path_results_to_sources.iterdir() if f.is_dir()]

    if verbosity > 0:
        msg = f"Found {len(sources)} source(s):"
        for source in sources:
            msg += f"\n  - {source.name}"
        logger.info(msg)

    if not sources:
        logger.error(f"No sources found in '{path_results_to_sources}'")
        sys.exit(1)

    path_dict = {f"{source.name}": source for source in sources}

    # for each source, figure out how many batches exist
    path_sources_to_batches = Path("workspace/segmentation/cellpose_202404/objects")
    for source_name, source_path in path_dict.items():
        path_source_to_batches = source_path / path_sources_to_batches
        if not path_source_to_batches.exists():
            logger.error(f"Path '{path_source_to_batches}' does not exist.")
            sys.exit(1)

        batches = [f for f in path_source_to_batches.iterdir() if f.is_dir()]

        # might not need msg but whatever
        msg = f"Found {len(batches)} batch(es) for source '{source_name}'"
        if verbosity == 1:
            msg += "."
        elif verbosity == 2:
            msg += ":"
            for batch in batches:
                msg += f"\n  - {batch.name}"
        elif verbosity == 3:
            msg += ":"
            for batch in batches:
                msg += f"\n  - {batch.name} ({batch})"

        if verbosity > 0:
            logger.info(msg)

        if not batches:
            logger.error(f"No batches found in '{path_source_to_batches}'")
            sys.exit(1)

        path_dict[source_name] = {f"{batch.name}": batch for batch in batches}

    # for each source and batch, figure out which plates exist
    for source_name, source_dict in path_dict.items():
        for batch_name, batch_path in source_dict.items():
            path_batch = batch_path / Path("plates")

            plates = [f for f in batch_path.iterdir() if f.is_dir()]

            msg = f"Found {len(plates)} plate(s) for source '{source_name}' in batch '{batch_name}'"
            if verbosity == 1:
                msg += "."
            elif verbosity == 2:
                msg += ":"
                for plate in plates:
                    msg += f"\n  - {plate.name}"
            elif verbosity == 3:
                msg += ":"
                for plate in plates:
                    msg += f"\n  - {plate.name} ({plate})"

            if verbosity > 0:
                logger.info(msg)

            if not plates:
                logger.error(f"No plates found in '{path_batch_to_plates}'")
                sys.exit(1)

            # filter out plate folders that don't contain a .zarr file
            for plate in plates:
                if not (plate / Path(f"{plate.name}.zarr")).exists():
                    plates.remove(plate)
                    if verbosity > 0:
                        logger.warning(
                            f"Plate '{plate.name}' does not contain a .zarr file and will be skipped."
                        )

            path_dict[source_name][batch_name] = {
                f"{plate.name}": plate for plate in plates
            }

    if verbosity > 0:
        logger.info("Creating joblist in output directory.")
        jobs_created: int = 0
        for source_name, source_dict in path_dict.items():
            for batch_name, batch_dict in source_dict.items():
                for plate_name, plate_path in batch_dict.items():
                    if not dry_run:
                        with open(
                            output_path
                            / Path(f"{source_name}__{batch_name}__{plate_name}.txt"),
                            "w",
                        ) as f:
                            # double-underscores in filename because placeholders contain single underscores
                            f.write("todo\n")
                            f.write(f"{plate_path}\n")
                            f.write("---\n")
                    jobs_created += 1
                    if verbosity == 3:
                        logger.info(
                            f"Created job for plate '{plate_name}' in batch '{batch_name}' for source '{source_name}'."
                        )
        logger.info(f"Created {jobs_created} job(s).")

        logger.success("Processing complete.")


if __name__ == "__main__":
    main()
